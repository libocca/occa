module occa

#---[ Setup ]-----------------
macro getenv(var::String)
    var = ccall((:getenv, "libc"),
                Ptr{Uint8},
                (Ptr{Uint8},),
                bytestring(var))

    if var == C_NULL
        error("getenv: undefined variable: ", var)
    end

    return bytestring(var)
end

macro libocca()
    occaDir = @getenv("OCCA_DIR")
    return bytestring(occaDir, "/lib/libocca.so")
end

#---[ Types ]-----------------
type device
    cDevice::Ptr{Void}

    function device(mode::String, arg1::Number = 0, arg2::Number = 0)
        convert(Int32, arg1)
        convert(Int32, arg2)

        cDevice = ccall((:occaGetDevice, @libocca()),
                        Ptr{Void},
                        (Ptr{Uint8}, Int32, Int32,),
                        bytestring(mode), arg1, arg2)

        new(cDevice)
    end
end

type stream
    cStream::Ptr{Void}

    function stream(ptr::Ptr{Void})
        new(ptr)
    end
end

type kernel
    cKernel::Ptr{Void}

    function kernel(cKernel)
        new(cKernel)
    end
end

type kernelInfo
    cKernelInfo::Ptr{Void}

    function kernelInfo(ptr::Ptr{Void})
        new(ptr)
    end
end

type memory
    cMemory::Ptr{Void}
    cTypes

    function memory(cMemory, cTypes)
        new(cMemory, cTypes)
    end
end

#---[ Device ]----------------
function finalizer(d::device)
    ccall((:occaDeviceFree, @libocca()),
          Void,
          (Ptr{Void},),
          d.cDevice)
end

function mode(d::device)
    cMode = ccall((:occaDeviceMode, @libocca()),
                  Ptr{Uint8},
                  (Ptr{Void},), d.cDevice)

    return bytestring(cMode)
end

function setCompiler(d::device,
                     compiler::String)
    ccall((:occaDeviceSetCompiler, @libocca()),
          Void,
          (Ptr{Void}, Ptr{Uint8},),
          d.cDevice, bytestring(compiler))
end

function setCompilerFlags(d::device,
                          compilerFlags::String)
    ccall((:occaDeviceSetCompilerFlags, @libocca()),
          Void,
          (Ptr{Void}, Ptr{Uint8},),
          d.cDevice, bytestring(compilerFlags))
end

function buildKernelFromSource(d::device,
                               filename::String,
                               functionName::String,
                               info::kernelInfo = C_NULL)
    if info == C_NULL
        cKernel = ccall((:occaBuildKernelFromSource, @libocca()),
                        Ptr{Void},
                        (Ptr{Void}, Ptr{Uint8}, Ptr{Uint8}, Ptr{Void},),
                        d.cDevice,
                        bytestring(filename),
                        bytestring(functionName),
                        C_NULL)
    else
        cKernel = ccall((:occaBuildKernelFromSource, @libocca()),
                        Ptr{Void},
                        (Ptr{Void}, Ptr{Uint8}, Ptr{Uint8}, Ptr{Void},),
                        d.cDevice,
                        bytestring(filename),
                        bytestring(functionName),
                        info.cKernelInfo)
    end

    return kernel(cKernel)
end

function buildKernelFromBinary(d::device,
                               filename::String,
                               functionName::String)
    cKernel = ccall((:occaBuildKernelFromBinary, @libocca()),
                    Ptr{Void},
                    (Ptr{Void}, Ptr{Uint8}, Ptr{Uint8},),
                    d.cDevice,
                    bytestring(filename),
                    bytestring(functionName))

    return kernel(cKernel)
end

function malloc(d::device, sourceAndType)
    if length(sourceAndType) != 2
        error("malloc second argument must be a tuple of (bytes, type) or (array, type)")
    end

    cTypes = sourceAndType[2]

    if isa(sourceAndType[1], Array)
        bytes = length(sourceAndType[1]) * sizeof(cTypes)

        source = sourceAndType[1]
        convert(Ptr{Void}, source)
    else
        bytes  = sourceAndType[1] * sizeof(cTypes)
        source = C_NULL
    end

    convert(Uint, bytes)

    cMemory = ccall((:occaDeviceMalloc, @libocca()),
                    Ptr{Void},
                    (Ptr{Void}, Uint, Ptr{Void},),
                    d.cDevice, bytes, source)

    return memory(cMemory, cTypes)
end

function genStream(d::device)
    cStream = ccall((:occaGenStream, @libocca()),
                    Ptr{Void},
                    (Ptr{Void},),
                    d.cDevice)

    return stream(cStream)
end

function getStream(d::device)
    cStream = ccall((:occaGetStream, @libocca()),
                    Ptr{Void},
                    (Ptr{Void},),
                    d.cDevice)

    return stream(cStream)
end

function setStream(d::device, s::stream)
    ccall((:occaSetStream, @libocca()),
          Void,
          (Ptr{Void}, Ptr{Void},),
          d.cDevice, s.cStream)
end

#---[ Kernel ]----------------
function finalizer(k::kernel)
    ccall((:occaKernelFree, @libocca()),
          Void,
          (Ptr{Void},),
          k.cKernel)
end

function mode(k::kernel)
    cMode = ccall((:occaKernelMode, @libocca()),
                  Ptr{Uint8},
                  (Ptr{Void},),
                  k.cKernel)

    return bytestring(cMode)
end

function getPreferredDimSize(k::kernel)
    return ccall((:occaKernelPreferredDimSize, @libocca()),
                 Int32,
                 (Ptr{Void},),
                 k.cKernel)
end

function setWorkingDims(k::kernel,
                        dims, items, groups)
    items_  = ones(Uint, 3)
    groups_ = ones(Uint, 3)

    for i = 1:dims
        items_[i]  = items[i]
        groups_[i] = groups[i]
    end

    ccall((:occaKernelSetAllWorkingDims, @libocca()),
          Void,
          (Ptr{Void},
           Int32,
           Uint, Uint, Uint,
           Uint, Uint, Uint,),
          info.cKernelInfo,
          dims,
          items_[1] , items_[2] , items_[3],
          groups_[1], groups_[2], groups_[3])
end

function run(k::kernel, args...)
    argList = ccall((:occaGenArgumentList, @libocca()),
                    Ptr{Void}, ())

    pos = 0
    for arg in args
        if isa(arg, memory)
            ccall((:occaArgumentListAddArg, @libocca()),
                  Void,
                  (Ptr{Void}, Int32, Ptr{Void},),
                  argList, pos, arg)
        else
            # Missing
            ccall((:occaArgumentListAddArg, @libocca()),
                  Void,
                  (Ptr{Void}, Int32, Ptr{Void},),
                  argList, pos, occaArg)
        end

        pos += 1
    end

    ccall((:occaKernelRun_, @libocca()),
          Void,
          (Ptr{Void}, Ptr{Void},),
          k.cKernel, argList)

    ccall((:occaArgumentListFree, @libocca()),
          Void,
          (Ptr{Void},),
          argList)
end

function timeTaken(k::kernel)
    return ccall((:occaKernelTimeTaken, @libocca()),
                 Float64,
                 (Ptr{Void},),
                 k.cKernel)
end

function addDefine(info::kernelInfo, macro_::String, value::String)
    occaValue = ccall((:occaString, @libocca()),
                      Ptr{Void},
                      (Ptr{Uint8},),
                      bytestring(value))

    ccall((:occaKernelInfoAddDefine, @libocca()),
          Void,
          (Ptr{Void}, Ptr{Uint8}, Ptr{Void},),
          info.cKernelInfo, bytestring(macro_), occaValue)
end

function finalizer(info::kernelInfo)
    ccall((:occaKernelInfoFree, @libocca()),
          Void,
          (Ptr{Void},),
          info.cKernelInfo)
end

#---[ Memory ]----------------
function finalizer(m::memory)
    ccall((:occaMemoryFree, @libocca()),
          Void,
          (Ptr{Void},),
          m.cMemory)
end

function mode(m::memory)
    cMode = ccall((:occaMemoryMode, @libocca()),
                  Ptr{Uint8},
                  (Ptr{Void},),
                  m.cMemory)

    return bytestring(cMode)
end

function memcpy(destTuple, srcTuple, bytes::Number)
    if isa(destTuple, memory)
        dest = destTuple.cMemory

        destOffset = 0
        convert(Uint, destOffset)

        destIsAMemory = true
    elseif isa(destTuple, Array)
        dest = pointer(destTuple)

        destOffset = 0
        convert(Uint, destOffset)

        destIsAMemory = false
    else
        dest = destTuple[1]

        if isa(dest, memory)
            dest = dest.cMemory
            destIsAMemory = true
        else
            dest = pointer(destTuple[1])
            destIsAMemory = false
        end

        destOffset = destTuple[2]
        convert(Uint, destOffset)
    end

    if isa(srcTuple, memory)
        src = srcTuple.cMemory

        srcOffset = 0
        convert(Uint, srcOffset)

        srcIsAMemory = true
    elseif isa(srcTuple, Array)
        src = pointer(srcTuple)

        srcOffset = 0
        convert(Uint, srcOffset)

        srcIsAMemory = false
    else
        src = srcTuple[1]

        if isa(src, memory)
            src = src.cMemory
            srcIsAMemory = true
        else
            src = pointer(srcTuple[1])
            srcIsAMemory = false
        end

        srcOffset = srcTuple[2]
        convert(Uint, srcOffset)
    end

    convert(Uint, bytes)

    if destIsAMemory
        if srcIsAMemory
            ccall((:occaCopyMemToMem, @libocca()),
                  Void,
                  (Ptr{Void}, Ptr{Void}, Uint, Uint, Uint,),
                  dest, src, bytes, destOffset, srcOffset)
        else
            ccall((:occaCopyPtrToMem, @libocca()),
                  Void,
                  (Ptr{Void}, Ptr{Void}, Uint, Uint,),
                  dest, src, bytes, destOffset)
        end
    else
        if srcIsAMemory
            ccall((:occaCopyMemToPtr, @libocca()),
                  Void,
                  (Ptr{Void}, Ptr{Void}, Uint, Uint,),
                  dest, src, bytes, srcOffset)
        else
            error("One of the arguments should be an OCCA memory type")
        end
    end
end

function swap(a::memory, b::memory)
    tmp       = a.cMemory
    a.cMemory = b.cMemory
    b.cMemory = tmp
end

end
